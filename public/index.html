<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Media Bridge</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 500px;
      margin: 50px auto;
      padding: 20px;
      background: #1a1a2e;
      color: #eee;
    }
    h1 { text-align: center; margin-bottom: 30px; }
    .status {
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
    }
    .status.disconnected { background: #4a1a1a; }
    .status.connected { background: #1a4a1a; }
    .status.connecting { background: #4a4a1a; }
    button {
      width: 100%;
      padding: 15px;
      font-size: 18px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      margin-bottom: 10px;
      transition: background 0.2s;
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    #connectBtn { background: #4CAF50; color: white; }
    #connectBtn:hover:not(:disabled) { background: #45a049; }
    #disconnectBtn { background: #f44336; color: white; }
    #disconnectBtn:hover:not(:disabled) { background: #da190b; }
    .meters {
      display: flex;
      gap: 20px;
      margin-top: 20px;
    }
    .meter {
      flex: 1;
      text-align: center;
    }
    .meter-bar {
      height: 150px;
      background: #333;
      border-radius: 8px;
      position: relative;
      overflow: hidden;
    }
    .meter-fill {
      position: absolute;
      bottom: 0;
      width: 100%;
      background: linear-gradient(to top, #4CAF50, #8BC34A, #FFEB3B, #f44336);
      transition: height 0.05s;
    }
    .meter label { display: block; margin-top: 10px; }
  </style>
</head>
<body>
  <h1>Media Bridge</h1>

  <div id="status" class="status disconnected">Disconnected</div>

  <button id="connectBtn">Connect</button>
  <button id="disconnectBtn" disabled>Disconnect</button>

  <div class="meters">
    <div class="meter">
      <div class="meter-bar">
        <div id="micLevel" class="meter-fill" style="height: 0%"></div>
      </div>
      <label>Mic (to server)</label>
    </div>
    <div class="meter">
      <div class="meter-bar">
        <div id="spkLevel" class="meter-fill" style="height: 0%"></div>
      </div>
      <label>Speaker (from server)</label>
    </div>
  </div>

  <script>
    const SAMPLE_RATE = 48000;
    const BUFFER_SIZE = 4096;

    let ws = null;
    let audioCtx = null;
    let micStream = null;
    let micProcessor = null;
    let playbackQueue = [];
    let isPlaying = false;

    const statusEl = document.getElementById('status');
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const micLevel = document.getElementById('micLevel');
    const spkLevel = document.getElementById('spkLevel');

    function setStatus(text, state) {
      statusEl.textContent = text;
      statusEl.className = 'status ' + state;
    }

    // Convert Float32 audio to Int16 PCM
    function floatTo16Bit(float32Array) {
      const int16 = new Int16Array(float32Array.length);
      for (let i = 0; i < float32Array.length; i++) {
        const s = Math.max(-1, Math.min(1, float32Array[i]));
        int16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
      }
      return int16;
    }

    // Convert Int16 PCM to Float32 audio
    function int16ToFloat(int16Array) {
      const float32 = new Float32Array(int16Array.length);
      for (let i = 0; i < int16Array.length; i++) {
        float32[i] = int16Array[i] / (int16Array[i] < 0 ? 0x8000 : 0x7FFF);
      }
      return float32;
    }

    // Calculate audio level (0-100)
    function getLevel(samples) {
      let sum = 0;
      for (let i = 0; i < samples.length; i++) {
        sum += samples[i] * samples[i];
      }
      const rms = Math.sqrt(sum / samples.length);
      return Math.min(100, rms * 300);
    }

    async function connect() {
      try {
        setStatus('Connecting...', 'connecting');

        // Get microphone access
        micStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            sampleRate: SAMPLE_RATE,
            channelCount: 1,
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false,
          }
        });

        // Setup AudioContext
        audioCtx = new AudioContext({ sampleRate: SAMPLE_RATE });

        // Connect microphone to processor
        const source = audioCtx.createMediaStreamSource(micStream);
        micProcessor = audioCtx.createScriptProcessor(BUFFER_SIZE, 1, 1);

        micProcessor.onaudioprocess = (e) => {
          if (ws?.readyState === WebSocket.OPEN) {
            const input = e.inputBuffer.getChannelData(0);
            micLevel.style.height = getLevel(input) + '%';
            const pcm = floatTo16Bit(input);
            ws.send(pcm.buffer);
          }
        };

        source.connect(micProcessor);
        micProcessor.connect(audioCtx.destination);

        // Connect WebSocket (relative to current path)
        const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        const basePath = location.pathname.replace(/\/$/, '');
        ws = new WebSocket(`${protocol}//${location.host}${basePath}/audio`);
        ws.binaryType = 'arraybuffer';

        ws.onopen = () => {
          setStatus('Connected', 'connected');
          connectBtn.disabled = true;
          disconnectBtn.disabled = false;
        };

        ws.onmessage = (e) => {
          const int16 = new Int16Array(e.data);
          const float32 = int16ToFloat(int16);
          spkLevel.style.height = getLevel(float32) + '%';
          playAudio(float32);
        };

        ws.onclose = () => {
          disconnect();
        };

        ws.onerror = (e) => {
          console.error('WebSocket error:', e);
          disconnect();
        };

      } catch (err) {
        console.error('Connection error:', err);
        setStatus('Error: ' + err.message, 'disconnected');
        disconnect();
      }
    }

    function playAudio(samples) {
      if (!audioCtx) return;

      const buffer = audioCtx.createBuffer(1, samples.length, SAMPLE_RATE);
      buffer.copyToChannel(samples, 0);

      const source = audioCtx.createBufferSource();
      source.buffer = buffer;
      source.connect(audioCtx.destination);
      source.start();
    }

    function disconnect() {
      if (ws) {
        ws.close();
        ws = null;
      }
      if (micProcessor) {
        micProcessor.disconnect();
        micProcessor = null;
      }
      if (micStream) {
        micStream.getTracks().forEach(t => t.stop());
        micStream = null;
      }
      if (audioCtx) {
        audioCtx.close();
        audioCtx = null;
      }

      setStatus('Disconnected', 'disconnected');
      connectBtn.disabled = false;
      disconnectBtn.disabled = true;
      micLevel.style.height = '0%';
      spkLevel.style.height = '0%';
    }

    connectBtn.onclick = connect;
    disconnectBtn.onclick = disconnect;
  </script>
</body>
</html>
